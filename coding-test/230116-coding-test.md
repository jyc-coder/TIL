## 코딩 테스트

프로그래머스 코딩테스트 lv.0 18일차 문제풀이 완료

- 겹치는 선분의 길이
- 유한소수 판별하기
- 저주의 숫자 3
- 평행


### 유한소수 판별하기
```js
function solution(a,b) {
    // 입력한 값의 조합을 기약분수로 만들기
    
    for (let i = 2; i < b; i++){
      if (a === 1 || b === 1){
        break;
      }
      if (a % i === 0 && b % i === 0){
        a = a/i
        b = b/i
      }
    }
   // 기약분수인 상태에서 분모의 인수 확인
  
    var what = []; // 빈배열 
    let index = 2
    while (b > 1){
        if ( b % index === 0) {
            b = Math.floor(b / index)
            what.push(index)
            index = 2;
        } 
      else{
        index++
      }
        
    }
  return (what.filter((e) => e !== 2 && e !== 5).length > 0 ? 2 : 1)
 
}



```
- 입력한 수 (a,b)로 만들어진 변수를 기약변수로 만든다 for문을 사용해서 분자나 분모가 1이 될때까지 반복 진행한다.

- 기약분수가 만들어졌으면 분모의 인수가 2나 5가 존재하는지 파악하기 위해서 분모를 소인수분해했다. while문을 사용해서 2부터 나누면서 나눠질 때마다 what이라는 배열에 추가하여 b가 1보다 클동안 계속 진행한다.

- 여기서 else를 사용하지 않고 index++만 사용했더니 시간 초과로 문제가 틀렸다고 나왔다. 아무래도 작은 구문이라도 else를 씌워줘야하나보다.

- 마짐가으로 what 배열을 filter 메서드를 사용해서 2나 5가 아닌 요소만 추가했고, 해당 과정을 거친 배열의 길이가 0보다 클경우에는 2나 5 가 아닌 다른 수를 인수로 가지고 있다는 뜻이 되기 때문에 2를 리턴하고 아니라면 1을 리턴한다.


다른 사람이 풀었던 내용중에서 유클리드 호제법으로 최대 공약수를 구해서 기약분수를 구하는 과정으로 문제를 풀었는데, 유클리드 호제법은 두수를 나눈 나머지가 존재한다면 다시 피연산자를 그 나머지로 나누는 과정을 반복해서 처음으로 나누어 떨어지는 순간 최대공약수가 되는 원리이다.

이를 이용해서 재귀 함수를 사용해서 최대공약수를 2줄로 줄였다. 
그이후의 나머지 과정은 비슷한다. 이런 방식으로 최대공약수를 구하는 과정이 매우 인상적이었다. 

수학은 역시 뗄려고 해도 뗄수가 없는 듯 하다 ㅜㅜ....

다른 풀이

```js

function solution(a,b) {
    // 최대 공약수 구하기 
    let gcd = (a, b) => {
    return a % b === 0 ? b : gcd(b, a % b);
  };

  let denom = b / gcd(a, b); // 분모  2
   // 기약분수인 상태에서 분모의 인수 확인
  
    var what = []; // 빈배열 
    let index = 2
    while (denom >= 2){
        if ( denom % index === 0) {
            denom = Math.floor(denom / index)
            what.push(index)
        } else{
            index++
        }
        
    }
 
return what.filter((e) => e !== 2 && e !== 5).length > 0 ? 2 : 1
}
```
